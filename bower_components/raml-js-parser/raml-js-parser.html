<!--
@license
Copyright 2016 The Advanced REST client authors
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="raml-js-parser-inports.html">
<!--
# `<raml-js-parser>`
The RAML parser (JS version) as a web component.

The `<raml-js-parser>` can accept an URL from where the API definition can be
downloaded or a RAML file from web filesystem. If the file contains references
to other files they can be passed as well to the `files` attribute and the pareser
will search files/directories structure for referenced file.

Files in web environment can be obtained if the user selects a file using
input file element or drop directory / files to a droppable element.

See demo for example of both.

### Events based approach

Parser can be included only once in the DOM and other element do not need to have
direct access to this element. It uses browser's events system to pass data.
The `<raml-js-parser>` will listen for `parse-raml-url`, `parse-raml-content`
and `parse-raml-file` events and in a result the event details will contain the
`raml` property which is a Promise that will resolve itself when parser
finish work.

#### `parse-raml-url` event
This event will be handled only if it contains the `url` property in the
event detail object. It should be an URL to the RAML resource that will be
downloaded.
Note, that the web app has to have an CORS access to the resource in order to
download it.

#### `parse-raml-content` event
This event if useful when the app already have content of the RAML file as string
and it's ready to parse it.
Additionally it may contain a list of files or directory structure where the
parser will search for delepndencies (referenced libraries).

This event will be handled only if it contains the `content` property in
the event detail object. Additional files or directory structure can be
passed in the `files` property.

#### `parse-raml-file` event
To be used when the app want to parse a RAML file which is a FileEntry or
a File (Blob) object. It similar to the `parse-raml-content` event but before
invoking the same method it will read file content firest.

This event will be handled only if it contains the `file` property in
the event detail object. Additional files or directory structure can be
passed in the `files` property.


### Example
``` html
<raml-js-parser></raml-js-parser>
```

``` javascript
// Handler for drop event
processFile = (e) => {
  var items = Array.from(e.dataTransfer.items);
  var main = this.findMainRamlFileSomehow(items);

  let detail = {
    'file': main,
    'files': items // this is optional.
  };
  let event = this.fire('parse-raml-file', detail);

  if (!event.detail.raml) {
    // uuups, raml parser is not attached to the DOM.
    return;
  }

  event.detail.raml.then((api) => {
    // api is the parser output.
  });
};
```

@group RAML Elements
@element raml-js-parser
@demo demo/demo.html
@hero hero.svg
-->
<script>
(function() {
'use strict';
/* global chrome */
var importLocation = '';
if (window.currentImport && window.currentImport.URL) {
  let url = window.currentImport.URL;
  let path = url.substr(url.indexOf('/', url.indexOf('/') + 2))
    .replace('raml-js-parser.html', '');
  let lastDot = path.lastIndexOf('.');
  if (lastDot !== -1 && path.substr(lastDot + 1) === 'html') {
    // remove element file name path
    path = path.substr(0, path.lastIndexOf('/') + 1);
  }
  importLocation = path;
}

class RamlJsParser {
  beforeRegister() {
    this.is = 'raml-js-parser';
    this._eventTarget = null;
    /**
     * Fired when the RAML file has been parsed and the result is ready.
     *
     * @event api-parse-ready
     * @param {Object} result The parsing result.
     */
    /**
     * Fired when error occurred while parsing the file.
     *
     * @event error
     * @param {Error} error The error object.
     */
    this.properties = {
      /**
       * A file entry object with the RAML spec.
       * The file can be obtained using web filesystem or file input.
       */
      ramlFile: Object,
      /**
       * List of files (from web filesystem) where the parser should
       * look for a libraries.
       */
      files: Array,
      /**
       * Latest parsed data.
       */
      latestResult: {
        type: Object,
        readOnly: true,
        notify: true
      },
      /**
       * Latest error message
       */
      latestError: {
        type: Object,
        readOnly: true,
        notify: true
      }
    };
  }

  attached() {
    this._eventTarget = Polymer.dom(this).host || document;
    this.listen(this._eventTarget, 'parse-raml-url', '_parseRamlUrl');
    this.listen(this._eventTarget, 'parse-raml-content', '_parseRamlContent');
    this.listen(this._eventTarget, 'parse-raml-file', '_parseRamlFile');
  }

  detached() {
    this.unlisten(this._eventTarget, 'parse-raml-url', '_parseRamlUrl');
    this.unlisten(this._eventTarget, 'parse-raml-content', '_parseRamlContent');
    this.unlisten(this._eventTarget, 'parse-raml-file', '_parseRamlFile');
  }

  _parseRamlUrl(event) {
    if (!event.detail.url) {
      return;
    }
    // Always stop the event from being propagated.
    event.stopImmediatePropagation();
    event.detail.raml = this.loadApi(event.detail.url);
  }

  _parseRamlContent(event) {
    if (!event.detail.content) {
      return;
    }
    // Always stop the event from being propagated.
    event.stopImmediatePropagation();
    if (event.detail.files) {
      this.files = event.detail.files;
    }
    event.detail.raml = this.parseRaml(event.detail.content);
  }

  _parseRamlFile(event) {
    if (!event.detail.file) {
      return;
    }
    // Always stop the event from being propagated.
    event.stopImmediatePropagation();
    this.ramlFile = event.detail.file;
    if (event.detail.files) {
      this.files = event.detail.files;
    }
    event.detail.raml = this.loadFiles();
  }

  /**
   * Parses RAML file content.
   *
   * @param {String} content The RAML file content to parse.
   * @return {Promise} A promise that will resolve itself when the
   * conent was parsed and rejects when error occured.
   */
  parseRaml(content) {
    return RAML.Parser.parseRAML(content, {
      fsResolver: {
        contentAsync: (path) => this.contentAsync(path)
      },
      httpResolver: {
        getResourceAsync: (path) => this.getResourceAsync(path)
      }
    }).then((api) => {
      this._setLatestResult(api);
      this.fire('api-parse-ready', {
        result: api
      });
      return api;
    }).catch((err) => {
      this._setLatestError(err);
      this.fire('error', {
        error: err
      });
      throw err;
    });
  }
  // Load API from the URL.
  loadApi(url) {
    return RAML.Parser.loadApi(url, {
      fsResolver: {
        contentAsync: (path) => this.contentAsync(path)
      },
      httpResolver: {
        getResourceAsync: (path) => this.getResourceAsync(path)
      }
    }).then((api) => {
      this._setLatestResult(api);
      this.fire('api-parse-ready', {
        result: api
      });
      return api;
    }).catch((err) => {
      this._setLatestError(err);
      this.fire('error', {
        error: err
      });
      throw err;
    });
  }

  /**
   * Handler for RAML's parser FsResolver.contentAsync.
   * It's purpose is to provide a content of the file.
   */
  contentAsync(path) {
    return new Promise((resolve, reject) => {
      this.findEntry(path).then((entry) => {
        if (!entry) {
          reject(new Error('Entry not found.'));
          return;
        }
        if (entry.isFile) { // typeof FileEntry
          entry.file((result) => {
            let reader = new FileReader();
            reader.addEventListener('loadend', (e) => {
              resolve(reader.result);
            });
            reader.addEventListener('error', (e) => {
              reject(e);
            });
            reader.readAsText(result);
          });
        } else if (!entry.isDirectory) {
          let reader = new FileReader();
          reader.addEventListener('loadend', (e) => {
            resolve(reader.result);
          });
          reader.addEventListener('error', (e) => {
            reject(e);
          });
          reader.readAsText(entry);
        } else {
          reject(new Error(`File entry for ${path} do not exists.`));
        }
      }).catch(reject);
    });
  }
  /**
   * Handler for RAML's parser HttpResolver.getResourceAsync.
   * It's purpose is to provide a content of the file downloading it
   * from the URL.
   */
  getResourceAsync(path) {
    return fetch(path).then((response) => {
      return response.text();
    }).then((text) => {
      return {
        content: text
      };
    });
  }

  // Load API from file defined in `ramlFile` attribute
  loadFiles() {
    return new Promise((resolve, reject) => {
      if (!this.ramlFile) {
        reject(new Error('No file entry available'));
        return;
      }
      if (this.ramlFile.isFile) { // typeof FileEntry
        this.ramlFile.file((result) => {
          let reader = new FileReader();
          reader.addEventListener('loadend', (e) => {
            resolve(this.parseRaml(reader.result));
          });
          reader.addEventListener('error', (e) => {
            reject(e);
          });
          reader.readAsText(result);
        });
      } else if (!this.ramlFile.isDirectory) {
        let reader = new FileReader();
        reader.addEventListener('loadend', (e) => {
          resolve(this.parseRaml(reader.result));
        });
        reader.addEventListener('error', (e) => {
          reject(e);
        });
        reader.readAsText(this.ramlFile);
      }
    });
  }

  /**
   * This function is called by the RAML parser's filesystem resolver.
   * It is used when files were provided to the element as a source of the
   * RAML definition. Source of the file can be web filesystem (by using
   * file drag and drop of input file).
   *
   * If the user dragged / selected more than one file this function will
   * search for a file identified by it's `path` in this files list.
   * If the ficle couldn't be found the parser continue parsing RAML but
   * information about the error will be included into `api.errors()`
   * function (`api` is the result of calling parse function).
   *
   * @param {String} path A path of the file to look for.
   * @return {Promise} Fulfilled promise will result with FileEntry | File
   * object or null if the wile couldn't be find.
   */
  findEntry(path) {
    var entries = this.files;
    if (!entries ||
      (entries.length === 1 && entries[0] === this.ramlFile)) {
      return Promise.resolve(null);
    }
    return new Promise((resolve, reject) => {
      // quick run to find a file in a root dir
      for (let i = 0, len = entries.length; i < len; i++) {
        let entry = entries[i];
        if (!entry.isDirectory) {
          if (entry.fullPath === path) {
            resolve(entry);
            return;
          }
        }
      }
      var all = [];
      entries.forEach((item) => {
        if (item.isDirectory) {
          all.push(this._processEntryPath(item, path));
        }
      });
      Promise.all(all).then((entries) => {
        entries = entries.filter((item) => item !== null);
        if (entries.length > 0) {
          resolve(entries[0]);
          return;
        }
        resolve(null);
      });
    });
  }
  /**
   * Recursively process the file entry that can be either a file
   * or the directory. This function is seachring for a file identified
   * by `path` parameter.
   *
   * @param {FileEntry|DirectoryEntry} entry An entry to process
   * @param {String} path A path of the searched file
   * @return {Promise} The promise will resolve when entry was found (will
   * return FileEntry), when entry wans't found (will return null) or in case
   * of directory it will return an array of recursive results.
   */
  _processEntryPath(entry, path) {
    if (entry.isDirectory) {
      return new Promise((resolve, reject) => {
        let reader = entry.createReader();
        let all = [];
        var readEntries = () => {
          reader.readEntries((result) => {
            let res = this._readDirectoryEntries(result, all, path);
            if (res) {
              readEntries();
            } else {
              Promise.all(all).then((candidates) => {
                let result = this._cleanUpCandidates(candidates);
                resolve(result);
              }).catch(reject);
            }
          }, reject);
        };
        readEntries();
      });
    } else {
      if (entry.fullPath === path) {
        return Promise.resolve(entry);
      } else if (entry.fullPath.substr(entry.fullPath.indexOf('/', 1)) === path) {
        // If the user dropped full directory the it need to remove first dir path
        return Promise.resolve(entry);
      }
    }
    return Promise.resolve(null);
  }

  /**
   * Handler function for Direcory's `readEntries` function.
   * It processes all files that are in this directory.
   *
   * @param {Array} results A result of calling DirectoryEntry.readEntries
   * @param {Array<Promise>} all A list of promises of reading a directory.
   * @param {String} path A path of the searched file
   */
  _readDirectoryEntries(results, all, path) {
    // No more entries
    if (!results.length) {
      return false;
    } else {
      for (let i = 0, len = results.length; i < len; i++) {
        all.push(this._processEntryPath(results[i], path));
      }
      return true;
    }
  }

  /**
   * Cleans the array of files found in the files array.
   * It always should be an array of nulls, array of nulls and one file
   * found or just a file.
   * It will remove all nulls and then look for a file to return.
   *
   * @param {Array} candidates A list of files returned by the recursive
   * search function
   * @return {FileEntry|null} A file or null if not found.
   */
  _cleanUpCandidates(candidates) {
    candidates = candidates.filter((item) => item !== null);
    var len = candidates.length;
    if (len === 0) {
      return null;
    }
    for (var i = 0; i < len; i++) {
      var item = candidates[i];
      if (item instanceof Array) {
        if (item.length > 0) {
          return item[0];
        }
      } else {
        return item;
      }
    }
  }
}
Polymer(RamlJsParser);
})();
</script>
